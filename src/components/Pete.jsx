/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import { useAnimations, useGLTF } from "@react-three/drei";
import React, { useEffect, useRef, useMemo } from "react";
import { SkeletonUtils } from "three-stdlib";
import { LoopOnce } from "three";
import { useCharacterAnimations } from "../contexts/CharacterAnimations";

function Pete({ player = 1, ...props }) {
  const group = useRef();
  const { scene, animations } = useGLTF("./models/pete.glb");
  const { 
    setAnimations, 
    animationIndex, 
    animations: contextAnimations,
    player1AnimationIndex,
    player2AnimationIndex,
    isCombatMode,
    player1IsDead,
    player2IsDead
  } = useCharacterAnimations();
  
  // Clone the scene to create independent instances
  const clonedScene = useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { actions, names } = useAnimations(animations, group);
  
  // Ref para mantener track de la animación actual
  const currentActionRef = useRef(null);

  // Determinar qué índice de animación usar
  const currentAnimationIndex = useMemo(() => {
    // Siempre usar los índices específicos de cada jugador
    return player === 1 ? player1AnimationIndex : player2AnimationIndex;
  }, [player, player1AnimationIndex, player2AnimationIndex]);

  // Determinar si el jugador está muerto
  const isPlayerDead = useMemo(() => {
    return player === 1 ? player1IsDead : player2IsDead;
  }, [player, player1IsDead, player2IsDead]);

  // Determinar si la animación actual es de muerte
  const isDeathAnimation = useMemo(() => {
    if (!names[currentAnimationIndex]) return false;
    const animationName = names[currentAnimationIndex].toLowerCase();
    return animationName.includes('die') || animationName.includes('death');
  }, [currentAnimationIndex, names]);

  useEffect(() => {
    if (contextAnimations.length === 0) {
      setAnimations(names);
    }
  }, [names, contextAnimations.length, setAnimations]);

  useEffect(() => {
    if (actions && names[currentAnimationIndex]) {
      const animationName = names[currentAnimationIndex];
      const action = actions[animationName];
      
      console.log(`🎬 Pete (Player ${player}) playing animation: "${animationName}" (Dead: ${isPlayerDead}, Death Anim: ${isDeathAnimation})`);
      
      // Si ya está reproduciendo la misma animación de muerte, no hacer nada
      if (isDeathAnimation && currentActionRef.current === animationName && isPlayerDead) {
        console.log(`💀 Pete (Player ${player}) already playing death animation, keeping it`);
        return;
      }
      
      // Detener suavemente la animación anterior si existe
      if (currentActionRef.current && actions[currentActionRef.current] && currentActionRef.current !== animationName) {
        console.log(`🔄 Pete (Player ${player}) transitioning from "${currentActionRef.current}" to "${animationName}"`);
        actions[currentActionRef.current].fadeOut(0.3);
      }
      
      // Actualizar referencia de animación actual
      currentActionRef.current = animationName;
      
      if (isDeathAnimation) {
        // Para animaciones de muerte: reproducir solo una vez y quedarse en el último frame
        console.log(`💀 Pete (Player ${player}) playing DEATH animation - will play ONCE and stay at final frame`);
        
        // Configurar la animación para que se reproduzca solo una vez
        action.reset();
        action.setLoop(LoopOnce, 1); // Usar constante de Three.js
        action.clampWhenFinished = true; // Quedarse en el último frame
        action.enabled = true;
        action.paused = false;
        action.fadeIn(0.3);
        action.play();
        
        // Agregar listener para confirmar que la animación terminó
        const onFinished = () => {
          console.log(`💀 Pete (Player ${player}) death animation FINISHED - staying at final frame`);
          action.paused = true; // Pausar en el último frame
        };
        
        // Remover listener anterior si existe
        action._mixer.removeEventListener('finished', onFinished);
        action._mixer.addEventListener('finished', onFinished);
        
      } else {
        // Para otras animaciones: comportamiento normal con loop
        action.reset();
        action.clampWhenFinished = false;
        action.fadeIn(0.3);
        action.play();
      }
      
      return () => {
        // Cleanup más suave
        if (actions[animationName]) {
          actions[animationName].fadeOut(0.3);
        }
      };
    }
  }, [currentAnimationIndex, actions, names, isDeathAnimation, isPlayerDead, player]);

  return (
    <group ref={group} {...props} dispose={null}>
      <primitive object={clonedScene} />
    </group>
  );
}

useGLTF.preload("./models/pete.glb");

export default Pete; 